{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport moment from 'moment';\nvar offset = 100;\n\nfunction buildEvent(column, left, width, dayStart) {\n  var startTime = moment(column.start);\n  var endTime = column.end ? moment(column.end) : startTime.clone().add(1, 'hour');\n  var dayStartTime = startTime.clone().hour(dayStart).minute(0);\n  var diffHours = startTime.diff(dayStartTime, 'hours', true);\n  column.top = diffHours * offset;\n  column.height = endTime.diff(startTime, 'hours', true) * offset;\n  column.width = width;\n  column.left = left;\n  return column;\n}\n\nfunction collision(a, b) {\n  return a.end > b.start && a.start < b.end;\n}\n\nfunction expand(ev, column, columns) {\n  var colSpan = 1;\n\n  for (var i = column + 1; i < columns.length; i++) {\n    var col = columns[i];\n\n    for (var j = 0; j < col.length; j++) {\n      var ev1 = col[j];\n\n      if (collision(ev, ev1)) {\n        return colSpan;\n      }\n    }\n\n    colSpan++;\n  }\n\n  return colSpan;\n}\n\nfunction pack(columns, width, calculatedEvents, dayStart) {\n  var colLength = columns.length;\n\n  for (var i = 0; i < colLength; i++) {\n    var col = columns[i];\n\n    for (var j = 0; j < col.length; j++) {\n      var colSpan = expand(col[j], i, columns);\n      var L = i / colLength * width;\n      var W = width * colSpan / colLength - 10;\n      calculatedEvents.push(buildEvent(col[j], L, W, dayStart));\n    }\n  }\n}\n\nfunction populateEvents(events, screenWidth, dayStart) {\n  var lastEnd;\n  var columns;\n  var calculatedEvents = [];\n  events = events.map(function (ev, index) {\n    return _objectSpread(_objectSpread({}, ev), {}, {\n      index: index\n    });\n  }).sort(function (a, b) {\n    if (a.start < b.start) return -1;\n    if (a.start > b.start) return 1;\n    if (a.end < b.end) return -1;\n    if (a.end > b.end) return 1;\n    return 0;\n  });\n  columns = [];\n  lastEnd = null;\n  events.forEach(function (ev) {\n    if (lastEnd !== null && ev.start >= lastEnd) {\n      pack(columns, screenWidth, calculatedEvents, dayStart);\n      columns = [];\n      lastEnd = null;\n    }\n\n    var placed = false;\n\n    for (var i = 0; i < columns.length; i++) {\n      var col = columns[i];\n\n      if (!collision(col[col.length - 1], ev)) {\n        col.push(ev);\n        placed = true;\n        break;\n      }\n    }\n\n    if (!placed) {\n      columns.push([ev]);\n    }\n\n    if (lastEnd === null || ev.end > lastEnd) {\n      lastEnd = ev.end;\n    }\n  });\n\n  if (columns.length > 0) {\n    pack(columns, screenWidth, calculatedEvents, dayStart);\n  }\n\n  return calculatedEvents;\n}\n\nexport default populateEvents;","map":{"version":3,"sources":["D:/Work/App-Zip/node_modules/react-native-calendars/src/timeline/Packer.js"],"names":["moment","offset","buildEvent","column","left","width","dayStart","startTime","start","endTime","end","clone","add","dayStartTime","hour","minute","diffHours","diff","top","height","collision","a","b","expand","ev","columns","colSpan","i","length","col","j","ev1","pack","calculatedEvents","colLength","L","W","push","populateEvents","events","screenWidth","lastEnd","map","index","sort","forEach","placed"],"mappings":"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","sourcesContent":["// @flow\nimport moment from 'moment';\n\nconst offset = 100;\n\nfunction buildEvent(column, left, width, dayStart) {\n  const startTime = moment(column.start);\n  const endTime = column.end ? moment(column.end) : startTime.clone().add(1, 'hour');\n  const dayStartTime = startTime.clone().hour(dayStart).minute(0);\n  const diffHours = startTime.diff(dayStartTime, 'hours', true);\n\n  column.top = diffHours * offset;\n  column.height = endTime.diff(startTime, 'hours', true) * offset;\n  column.width = width;\n  column.left = left;\n  return column;\n}\n\nfunction collision(a, b) {\n  return a.end > b.start && a.start < b.end;\n}\n\nfunction expand(ev, column, columns) {\n  let colSpan = 1;\n\n  for (let i = column + 1; i < columns.length; i++) {\n    let col = columns[i];\n    for (let j = 0; j < col.length; j++) {\n      let ev1 = col[j];\n      if (collision(ev, ev1)) {\n        return colSpan;\n      }\n    }\n    colSpan++;\n  }\n\n  return colSpan;\n}\n\nfunction pack(columns, width, calculatedEvents, dayStart) {\n  let colLength = columns.length;\n\n  for (let i = 0; i < colLength; i++) {\n    let col = columns[i];\n    for (let j = 0; j < col.length; j++) {\n      const colSpan = expand(col[j], i, columns);\n      const L = (i / colLength) * width;\n      const W = (width * colSpan) / colLength - 10;\n\n      calculatedEvents.push(buildEvent(col[j], L, W, dayStart));\n    }\n  }\n}\n\nfunction populateEvents(events, screenWidth, dayStart) {\n  let lastEnd;\n  let columns;\n  let calculatedEvents = [];\n\n  events = events\n    .map((ev, index) => ({...ev, index: index}))\n    .sort(function (a, b) {\n      if (a.start < b.start) return -1;\n      if (a.start > b.start) return 1;\n      if (a.end < b.end) return -1;\n      if (a.end > b.end) return 1;\n      return 0;\n    });\n\n  columns = [];\n  lastEnd = null;\n\n  events.forEach(function (ev) {\n    if (lastEnd !== null && ev.start >= lastEnd) {\n      pack(columns, screenWidth, calculatedEvents, dayStart);\n      columns = [];\n      lastEnd = null;\n    }\n\n    let placed = false;\n    for (let i = 0; i < columns.length; i++) {\n      let col = columns[i];\n      if (!collision(col[col.length - 1], ev)) {\n        col.push(ev);\n        placed = true;\n        break;\n      }\n    }\n\n    if (!placed) {\n      columns.push([ev]);\n    }\n\n    if (lastEnd === null || ev.end > lastEnd) {\n      lastEnd = ev.end;\n    }\n  });\n\n  if (columns.length > 0) {\n    pack(columns, screenWidth, calculatedEvents, dayStart);\n  }\n  return calculatedEvents;\n}\n\nexport default populateEvents;\n"]},"metadata":{},"sourceType":"module"}